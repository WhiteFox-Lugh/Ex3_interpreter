# 実験3 ソフトウェアฅ(´ω｀)ฅ

型推論機能を備えたインタプリタの実装

∩(´･ω･｀)つ―*’“*:.｡. .｡.:*･゜ﾟ･*

## 実装とかメモとか

オプション課題の★の数は自力では27個。
時間あったらExercise 3.5.2いけたかも（バグった）。

あとブランチについて。

- master branch: 課題3
- popuko branch: 課題2
- pipimi branch: 課題2で本来こっちに引き継ぐ予定だった（ポプ子の方が長いのダメ感ある）
- その他のbranch: 使い物にならない

### ML1
  
- [x] Ex.3.2.1 [必修]

  ```
  ML1 インタプリタのプログラムをコンパイル・実行し，インタプリタの動作を確かめよ．
  大域環境としてi, v, x の値のみが定義されているが，ii が2，iii が3，iv が
  4 となるようにプログラムを変更して，動作を確かめよ．例えば，
  iv + iii * ii
  などを試してみよ．
  ```

- [x] Ex.3.2.2 [★★]

  ```
  このインタプリタは文法にあわない入力を与えたり，束縛されていない変数を参照しようとすると，
  プログラムの実行が終了してしまう．このような入力を与えた場合，
  適宜メッセージを出力して，インタプリタプロンプトに戻るように改造せよ．
  ```

- [x] Ex.3.2.3 [★]

  ```
  論理値演算のための二項演算子 &&, || を追加せよ．
  ```

- [x] Ex.3.2.4 [★★]
  
  ```
  lexer.mll を改造し，(* と*) で囲まれたコメントを読み飛ばすようにせよ．
  なお，OCaml のコメントは入れ子にできることに注意せよ．
  ocamllex のドキュメントを読む必要があるかもしれない．
  （ヒント：comment という再帰的なルールをlexer.mllに新しく定義するとよい．
  ```

### ML2
  
- [x] Ex.3.3.1 [必修]

  ```
  ML2 インタプリタを作成し，テストせよ．
  ```

- [x] Ex.3.3.2 [★★]

  ```
  OCaml では，let 宣言の列を一度に入力することができる．
  この機能を実装せよ．以下は動作例である．
  # let x = 1
  let y = x + 1;;
  val x = 1
  val y = 2
  ```
- [x] Ex.3.3.3 [★★]

  ```
  バッチインタプリタを作成せよ．具体的にはminiml コマンドの引数として
  ファイル名をとり，そのファイルに書かれたプログラムを評価し，
  結果をディスプレイに出力するように変更せよ．また，コメントを無視するよう実装せよ．
  (オプション: ;; で区切られたプログラムの列が読み込めるようにせよ．)
  ```

- [x] Ex.3.3.4 [★★]
  ```
  and を使って変数を同時にふたつ以上宣言できるようにlet 式・宣言を拡張せよ．
  例えば以下のプログラム
  let x = 100
  and y = x in x+y
  の実行結果は200 ではなく，(x が大域環境で10 に束縛されているので) 110 である．
  ```
  
### ML3
  
- [x] Ex.3.4.1 [必修]
  ```
  ML3 インタプリタを作成し，高階関数が正しく動作するかなどを含めてテストせよ．
  ```

- [x] Ex.3.4.2 [★★]
  ```
  OCaml での「(中置演算子) 」記法をサポートし，プリミティブ演算を通常の関数と
  同様に扱えるようにせよ．例えば
  let threetimes = fun f -> fun x -> f (f x x) (f x x) in
  threetimes (+) 5
  は，20 を出力する．
  ```

- [x] Ex.3.4.3 [★]
  ```
  OCaml の
  fun x1 ... xn -> ...
  let f x1 ... xn = ...
  といった簡略記法をサポートせよ．
  ```

- [x] Ex.3.4.4 [★]
  ```
  以下は，加算を繰り返して4 による掛け算を実現しているML3 プログラムである．
  これを改造して，階乗を計算するプログラムを書け．
  let makemult = fun maker -> fun x ->
  if x < 1 then 0 else 4 + maker maker (x + -1) in
  let times4 = fun x -> makemult makemult x in
  times4 3
  ```
  
- [x] Ex.3.4.5 [★]
  ```
  静的束縛とは対照的な概念として動的束縛(dynamic binding) がある．
  動的束縛の下では，関数本体は，関数式を評価した時点ではなく，関数呼び出しがあった時
  点での環境をパラメータ・実引数で拡張した環境下で評価される．インタプリタを改造し，
  fun の代わりにdfun を使った関数は動的束縛を行うようにせよ．例えば，
  let a = 3 in
  let p = dfun x -> x + a in
  let a = 5 in
  a * p 2
  というプログラムでは，関数p 本体中のa は3 ではなく5 に束縛され，結果は，35 になる．
  (fun を使った場合は25 になる．)
  ```
  
- [x] Ex.3.4.6 [★]
  ```
  動的束縛の下では，ML4 で導入するような再帰定義を実現するための特別な仕組みや，
  Exercise 3.4.4 のようなトリックを使うことなく，再帰関数を定義できる．
  以下のプログラムで，二箇所のfun をdfun (Exercise3.4.5 を参照)
  に置き換えて(4 通りのプログラムを) 実行し，その結果について説明せよ．
  let fact = fun n -> n + 1 in
  let fact = fun n -> if n < 1 then 1 else n * fact (n + -1) in
  fact 5
  ```

### ML4
  
- [x] Ex.3.5.1 [必修]
  ```
  図に示したsyntax.ml にしたがって，parser.mly とlexer.mll を完成させ，
  ML4 インタプリタを作成し，テストせよ．(let rec 宣言も実装すること．)
  ```

- [ ] Ex.3.5.2 [★★]
  ```
  and を使って変数を同時にふたつ以上宣言できるように
  let rec 式・宣言を拡張し，相互再帰的関数をテストせよ．
  ```

### ML5
  
- [x] Ex.3.6.1 [★★]
  ```
  今までのことを応用して，空リスト[]，右結合の二項演算子::，match式を導入して，
  リストが扱えるようにML4 インタプリタを拡張せよ．match 式の構文は，
  match ⟨式1⟩ with [] -> ⟨式2⟩ | ⟨識別子1⟩ :: ⟨識別子2⟩ -> ⟨式1⟩
  程度の制限されたものでよい．
  ```

- [x] Ex.3.6.2 [★]
  ```
  リスト表記
  [⟨式1⟩; ... ; ⟨式n⟩]
  をサポートせよ．
  ```

- [x] Ex.3.6.3 [★]
  ```
  match 式のパターン部において，リストの先頭と残りを表す変数
  (:: の両側) に同じものが使われていた場合にエラーを発生するように改良せよ．
  ```
  
- [ ] Ex.3.6.4 [★★★]
  ```
  より一般的なパターンマッチ構文を実装せよ．
  ```

- [x] Ex.3.6.5 [★★]
  ```
  ここまで与えた構文規則では，OCaml とは異なり， if，let, fun, match
  式などの「できるだけ右に延ばして読む」構文が二項演算子の右側に来た場合，
  括弧が必要になってしまう．この括弧が必要なくなるような構文規則を与えよ．
  例えば，
  1 + if true then 2 else 3;;
  などが正しいプログラムとして認められるようにせよ
  ```

- [ ] Ex.3.6.6、Ex.3.6.7 [(`･ω･´)]

### ML2 型推論
  
- [x] Ex.4.2.1 [必修]
  ```
  図4.1, 図4.2 に示すコードを参考にして，型推論アルゴリズムを完成させよ．
  ```

### ML3 型推論
  
- [x] Ex.4.3.1 [必修]
  ```
  図4.3 中のpp_ty，freevar_ty を完成させよ．freevar_ty は，
  与えられた型中の型変数の集合を返す関数で，型は
  val freevar_ty : ty -> tyvar MySet.t
  とする．型'a MySet.t はmySet.mli で定義されている'a を要素とする
  集合を表す型である
  ```

- [x] Ex.4.3.2 [必修]
  ```
  型代入に関する以下の型，関数をtyping.ml 中に実装せよ．
  type subst = (tyvar * ty) list
  val subst_type : subst -> ty -> ty
  例えば，
  let alpha = fresh_tyvar () in
  subst_type [(alpha, TyInt)] (TyFun (TyVar alpha, TyBool))
  の値はTyFun (TyInt, TyBool) になり，
  let alpha = fresh_tyvar () in
  let beta = fresh_tyvar () in
  subst_type [(beta, (TyFun (TyVar alpha, TyInt))); (alpha, TyBool)] (TyVar beta)
  の値はTyFun (TyBool, TyInt) になる．
  ```
- [x] Ex.4.3.3 [必修]
  ```
  上の単一化アルゴリズムを
  val unify : (ty * ty) list -> subst
  として実装せよ．
  ```
- [x] Ex.4.3.4 [必修]
  ```
  単一化アルゴリズムにおいて，α is not an element of FTV(τ) という条件は
  なぜ必要か考察せよ．
  ```

- [x] Ex.4.3.5 [必修]
  ```
  他の型付け規則に関しても同様に型推論の手続きを与えよ(レポートの一部としてまとめよ)．
  そして，図4.4 を参考にして，型推論アルゴリズムの実装を完成させよ．
  ```

- [x] Ex.4.3.6 [★★]
  ```
  再帰的定義のためのlet rec 式の型付け規則は以下のように与えられる.
  （T-LETRECの規則がここにある）
  型推論アルゴリズムがlet rec 式を扱えるように拡張せよ．
  ```

- [x] Ex.4.3.7 [★★]
  ```
  以下は，リスト操作に関する式の型付け規則である．
  リストには要素の型をτとしてτ list という型を与える．
  (T-NIL),(T-CONS),(T-MATCH)
  型推論アルゴリズムがこれらの式を扱えるように拡張せよ
  ```
  
### 多相的 let の型推論

やっていない。

- [ ] Ex.4.4.1 [★★]
  ```
  図4.5, 4.6 を参考にして，多相的let 式・宣言ともに扱える型推論アルゴリズムの実装を完成させよ．
  ```

- [ ] Ex.4.4.2 [★]
  ```
  以下の型付け規則を参考にして，再帰関数が多相的に扱えるように，
  型推論機能を拡張せよ．
  (T-LETREC)
  ```

- [ ] Ex.4.4.3 [★★★]
  ```
  OCaml では，「: ⟨ 型⟩」という形式で，式や宣言された変数の型を
  指定することができる．この機能を扱えるように処理系を拡張せよ．
  ```

- [ ] Ex.4.4.4 [★★★]
  ```
  型推論時のエラー処理を，プログラマにエラー箇所がわかりやすくなるように改善せよ．
  ```