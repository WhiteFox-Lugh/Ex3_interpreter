# 実験3 ソフトウェアฅ(´ω｀)ฅ

型推論機能を備えたインタプリタの実装

∩(´･ω･｀)つ―*’“*:.｡. .｡.:*･゜ﾟ･*

## 実装とかメモとか

「プログラミング言語処理系」（僕が受講当時の講義名）の中間試験と連動しているので、実装しながら理解を深めていくと実験も進むし中間試験・期末試験も良い点取れるのでおすすめです。担当者が変わっていなければの話だけど。

この実験はgitで管理することを推奨します。diff見ればレポート書きやすくなるし、バグっても戻せるし、Ex3とEx4以降でどうせ分けないといけない（Ex3のものとEx4のものが同時に実装できないものがいくつかある）ので。<small>あと、gitで管理していない人の死亡報告もtwitterで見てしまったので...。逆にgit使わずどうやって管理してたんだ。</small>

以下、課題の問題文と、それに関する備忘録と、オプション課題については私の主観的な実装難易度（5段階:最低1、最高5）と発想難易度（3段階: 易A、普通B、やや難C）が書いてあります。実装難易度は実際に実装するときの分量とかにあたるところで、発想難易度は方針とかのひらめき力に関する難易度です。当然個人差はあります。参考程度に。

オプション課題の★の数は自力では27個稼ぎました。
時間あったらExercise 3.5.2いけたかも（バグった）。
多相letは普通に難しいのと一般的パターンマッチ（Exercise 3.6.4）はヤバい。
僕の友人は★25個前後の人が多く、中には30個越えもいました（友人、強すぎない？）。

あとブランチについて。

- master branch: 課題3
- popuko branch: 課題2
- pipimi branch: 課題2で本来こっちに引き継ぐ予定だった（ポプ子の方が長いのダメ感ある）
- その他のbranch: 使い物にならない

最後に、<font color="red"><strong>不正は絶対にしないように。</strong></font>ソースコードのコピペなんてナンセンスなことしてバレて留年したとかそういうことがあっても僕は一切責任とれません。僕が学生実験でOCamlを書いたんだという証、今後いろいろなものを実装する時に参考にするためにこのレポジトリは残しています。

### ML1
  
- [x] Ex.3.2.1 [必修]
  ```
  ML1 インタプリタのプログラムをコンパイル・実行し，インタプリタの動作を確かめよ．
  大域環境としてi, v, x の値のみが定義されているが，ii が2，iii が3，iv が
  4 となるようにプログラムを変更して，動作を確かめよ．例えば，
  iv + iii * ii
  などを試してみよ．
  ```
  環境構築ですね(´･_･`)

- [x] Ex.3.2.2 [★★]
  ```
  このインタプリタは文法にあわない入力を与えたり，束縛されていない変数を参照しようとすると，
  プログラムの実行が終了してしまう．このような入力を与えた場合，
  適宜メッセージを出力して，インタプリタプロンプトに戻るように改造せよ．
  ```
  課題1で例外処理とかやったのでその辺できれば。難易度逆詐称気味。
  * 実装難易度: 1
  * 発想難易度: A

- [x] Ex.3.2.3 [★]
  ```
  論理値演算のための二項演算子 &&, || を追加せよ．
  ```
  短絡評価をどうするか、がポイントですね（僕より上の代では短絡評価しなくても大丈夫だったころがあるらしい）。実験のページのFAQはちょっと不親切な気が。配布されたソースコードだと左辺と右辺を評価して`BinOp`の処理をしているのでこれでは短絡評価にならない。
  
  ちなみに短絡評価ができていないと2ケースほど落ちます（年度によって違うかも）。あと、`&&`、`||`にトークンの名前をつける時に`AND`、`OR`にしない方がいい。僕は`LAND`（logical AND）、`LOR`（logical OR）にしました。
  * 実装難易度: 2
  * 発想難易度: A

- [x] Ex.3.2.4 [★★]
  ```
  lexer.mll を改造し，(* と*) で囲まれたコメントを読み飛ばすようにせよ．
  なお，OCaml のコメントは入れ子にできることに注意せよ．
  ocamllex のドキュメントを読む必要があるかもしれない．
  （ヒント：comment という再帰的なルールをlexer.mllに新しく定義するとよい．
  ```
  lexer.mllを改造しろという文言と、ヒント書いてあるのでとても優しい（なおこれ以降の課題はノーヒント）。うまく入れ子の回数をカウントできるといいのでは。
  * 実装難易度: 1
  * 発想難易度: A

### ML2
  
- [x] Ex.3.3.1 [必修]
  ```
  ML2 インタプリタを作成し，テストせよ．
  ```
  やるだけ(`･ω･´)b

- [x] Ex.3.3.2 [★★]
  ```
  OCaml では，let 宣言の列を一度に入力することができる．
  この機能を実装せよ．以下は動作例である．
  # let x = 1
  let y = x + 1;;
  val x = 1
  val y = 2
  ```
  見た目よりは難しい。とりあえず、初期のDeclだと1個しかlet宣言できないので続けて複数やりたいと考えると、parserとかsyntaxとかいじりたくなる気はする。eval.mlにいい感じに再帰的に宣言の文を評価できるものが実装できると良さそう。ところで、宣言した内容を複数表示するにはmain.mlに1行置いておくだけじゃ足りない。あと、動作例からは一切わからないが、OCamlでは、この構文については、同じ変数名を使うと、後に宣言したものが優先される。
  ```
  # let a=3 let b=4 let c=5 let a=6;;
  val b : int = 4
  val c : int = 5
  val a : int = 6
  ```
  正直これ、他の人に言われなければ気づかなかったぞ...(´･_･`)。テストケースに含まれていたような気がするので実装しなきゃダメっぽい。複数宣言するよりこれの実装の方がめんどくさかった気がする。
  * 実装難易度: 3
  * 発想難易度: B

- [x] Ex.3.3.3 [★★]
  ```
  バッチインタプリタを作成せよ．具体的にはminiml コマンドの引数として
  ファイル名をとり，そのファイルに書かれたプログラムを評価し，
  結果をディスプレイに出力するように変更せよ．また，コメントを無視するよう実装せよ．
  (オプション: ;; で区切られたプログラムの列が読み込めるようにせよ．)
  ```
  引数の数によって処理を分ければいいだけ。ただ、オプションにあるように;;で区切られたプログラムの列が読み込めるようにするのは普通に面倒かも。
  * 実装難易度: オプションやらなければ 2
  * 発想難易度: オプションやらなければ A

  * [x] Ex.3.3.4 [★★]
  ```
  and を使って変数を同時にふたつ以上宣言できるようにlet 式・宣言を拡張せよ．
  例えば以下のプログラム
  let x = 100
  and y = x in x+y
  の実行結果は200 ではなく，(x が大域環境で10 に束縛されているので) 110 である．
  ```
  <s>3.3.4って見て阪神(ryってなる人多いのでは。</s>
  Exercise 3.2.3で`&&`をANDっていうトークン名にしているとここでアーッ！ってなるはず。

  Exercise 3.3.2との違いを考える。実行例のように`x = 10`が大域環境にある場合は、`let y = x`は x を 100 という値に束縛したという情報を付け加えた環境では評価してはいけない（言い方が不正確な気はするけど察して）。これがわかればいけると思う。

  あとは、実行例からはわからないが、同じ変数名を宣言することはできない。
  ```
  # let x = 100 and x = 334;;
  Error: Variable x is bound several times in this matching
  ```
  * 実装難易度: 3
  * 発想難易度: B
  
### ML3
  
- [x] Ex.3.4.1 [必修]
  ```
  ML3 インタプリタを作成し，高階関数が正しく動作するかなどを含めてテストせよ．
  ```
  <s>資料のコピペでいけるやん！この実験ぬるいわー！とか言ってた人がここでつまづいていた気がする。</s>
  まあ、基本的には資料通りにやればいいんですけど、ちょっと足りない。でも足りない箇所はエラーメッセージを見ればわかるわけで。

  <font color="red">ところで、実験のサイトの全然目立たないところに関数型の値の表示形式についてこんなことが書いてあります。

  「&lt;と&gt;で囲まれた適当な文字列．関数の中身によって表示を変える必要はない(e.g. &lt;fun&gt;, &lt;dfun&gt;)

  つまり`val f = <fun>`とかはOKで`val f = fun`とかはテストケース通らないんですよ。これで通らない！って嘆いていた人がそこそこいたし、必修やるときは気をつけていても他の課題やる時についうっかり忘れてたっていう人が多かった。気をつけて！！</font> 文字化けとかしない程度に遊ぶといいと思います。僕は`< (`･ω･´)つ<fun> >`にしました。オメガとかひらがなとかはテストケース通るんですね。

- [x] Ex.3.4.2 [★★]
  ```
  OCaml での「(中置演算子) 」記法をサポートし，プリミティブ演算を通常の関数と
  同様に扱えるようにせよ．例えば
  let threetimes = fun f -> fun x -> f (f x x) (f x x) in
  threetimes (+) 5
  は，20 を出力する．
  ```
  プリミティブ演算なので、`+`と`*`と`<`だけで大丈夫。ただし、Exercise3.2.3を通している人は`&&`と`||`も通さないとダメです（テストケースに`(Ex.3.4.2&Ex.3.2.3)`と書いてあるものが存在する）。
  例えば、`(+) x y`ってこのインタプリタに合うように関数の構文で書くと`fun x -> fun y -> x + y`っていうことになるはず。ということは2引数の関数と見ることができる。しかし、`(+) 3 4`とかやると`fun 3 -> fun 4 -> 3 + 4`ということになってしまう（OCamlだとエラーになりそうだけど、実はWarning出ながらも定義「は」できるが使いものにならないゴミ）のでこれをうまく処理したい。実は、今ある`BinOp`と`FunExp`の処理をうまく使うと、実は構文規則をいじるだけでできてしまう（ここに気づくまでが結構難しい）。
  * 実装難易度: 2
  * 発想難易度: C

- [x] Ex.3.4.3 [★]
  ```
  OCaml の
  fun x1 ... xn -> ...
  let f x1 ... xn = ...
  といった簡略記法をサポートせよ．
  ```
  `fun x1 -> fun x2 -> ,,, -> fun xn = ...`とかと同じであることに気づけばきっとできますよね。
  * 実装難易度: 1
  * 発想難易度: A

- [x] Ex.3.4.4 [★]
  ```
  以下は，加算を繰り返して4 による掛け算を実現しているML3 プログラムである．
  これを改造して，階乗を計算するプログラムを書け．
  let makemult = fun maker -> fun x ->
  if x < 1 then 0 else 4 + maker maker (x + -1) in
  let times4 = fun x -> makemult makemult x in
  times4 3
  ```
  このコードがどういう挙動するかわかればできる。もちろん、自分の実行環境上で実際に動かして見れば良い。
  * 実装難易度: 1
  * 発想難易度: A
  
- [x] Ex.3.4.5 [★]
  ```
  静的束縛とは対照的な概念として動的束縛(dynamic binding) がある．
  動的束縛の下では，関数本体は，関数式を評価した時点ではなく，関数呼び出しがあった時
  点での環境をパラメータ・実引数で拡張した環境下で評価される．インタプリタを改造し，
  fun の代わりにdfun を使った関数は動的束縛を行うようにせよ．例えば，
  let a = 3 in
  let p = dfun x -> x + a in
  let a = 5 in
  a * p 2
  というプログラムでは，関数p 本体中のa は3 ではなく5 に束縛され，結果は，35 になる．
  (fun を使った場合は25 になる．)
  ```
  難しそうに見えるけどちゃんと動的束縛と静的束縛の違いがわかっていればすぐです。静的束縛は、関数適用式が来た時に、クロージャから環境を取り出してその環境を用いていろいろやっていたのですが、動的束縛は「関数呼び出しがあった時点での環境をパラメータ・実引数で拡張した環境下で評価」です。
  * 実装難易度: 1
  * 発想難易度: A
  
- [x] Ex.3.4.6 [★]
  ```
  動的束縛の下では，ML4 で導入するような再帰定義を実現するための特別な仕組みや，
  Exercise 3.4.4 のようなトリックを使うことなく，再帰関数を定義できる．
  以下のプログラムで，二箇所のfun をdfun (Exercise3.4.5 を参照)
  に置き換えて(4 通りのプログラムを) 実行し，その結果について説明せよ．
  let fact = fun n -> n + 1 in
  let fact = fun n -> if n < 1 then 1 else n * fact (n + -1) in
  fact 5
  ```
  各プログラムがどういう挙動をするか、コードをなぞってみましょう。

### ML4
  
- [x] Ex.3.5.1 [必修]
  ```
  図に示したsyntax.ml にしたがって，parser.mly とlexer.mll を完成させ，
  ML4 インタプリタを作成し，テストせよ．(let rec 宣言も実装すること．)
  ```
  再帰の実装のおかげで、ちょっとだけ他のところもいじらないといけなくなりますね。わからないならエラーメッセージを参考にするしかないです。

- [ ] Ex.3.5.2 [★★]
  ```
  and を使って変数を同時にふたつ以上宣言できるように
  let rec 式・宣言を拡張し，相互再帰的関数をテストせよ．
  ```
  チェックついていないのでできていません(´・ω・`) テスト期間直後に実装しようと思ったので間に合わなかった。
  * 実装難易度: ?
  * 発想難易度: ?

### ML5
  
- [x] Ex.3.6.1 [★★]
  ```
  今までのことを応用して，空リスト[]，右結合の二項演算子::，match式を導入して，
  リストが扱えるようにML4 インタプリタを拡張せよ．match 式の構文は，
  match ⟨式1⟩ with [] -> ⟨式2⟩ | ⟨識別子1⟩ :: ⟨識別子2⟩ -> ⟨式1⟩
  程度の制限されたものでよい．
  ```
  ここまでのことをきちんと理解していれば、方針には困らないが実装量がそこそこある感じ。たぶん難しいとしたら、consリストの扱いができるようになるところでしょうか。`1 :: 2 :: 3 :: []`とかその程度の実装で大丈夫です。まだ型推論もやっていないので`1 :: true :: []`とか通ってしまっても大丈夫です。
  
  まず、リストについての`exval`を作る必要がありそうですね。あとは、リストまわりの`[1; 2; 3]`みたいな出力を工夫するくらいでしょうか。空リストを要素とするリスト`[[]; []; []]`などもテストケースにあったかもしれない。
  * 実装難易度: 4
  * 発想難易度: A

- [x] Ex.3.6.2 [★]
  ```
  リスト表記
  [⟨ 式1⟩; ... ; ⟨ 式n⟩]
  をサポートせよ．
  ```
  どこまでサポートすればいいかわからんかったのでちょっと悪いやり方ですが、テストケース数をみて想像しました。おそらくですが入れ子リストが3ケースほど入っています。頑張って。
  * 実装難易度: 2
  * 発想難易度: A

- [x] Ex.3.6.3 [★]
  ```
  match 式のパターン部において，リストの先頭と残りを表す変数
  (:: の両側) に同じものが使われていた場合にエラーを発生するように改良せよ．
  ```
  Ex.3.6.1が実装できてしまえばサービス問題ですね...(´･_･`)。なお、宣言する時にエラーをはかなくても良い（let hoge = fun n -> match ... と宣言する時にエラー吐かせるのは難しい）。
  * 実装難易度: 1
  * 発想難易度: A
  
- [ ] Ex.3.6.4 [★★★]
  ```
  より一般的なパターンマッチ構文を実装せよ．
  ```
  手をつけなかった。めんどくさいのが目に見えてわかるから。実際、同学年の某強者でさえ課題2のオプションで唯一これだけ残したらしい。誰か余裕のある後輩、通してみて。実装力も必要だけど、「一般的」ってどこまで実装すればいいのか、そういうのも考えなければいけなさそう。
  * 実装難易度: 5（推定値）
  * 発想難易度: C（推定値）

- [x] Ex.3.6.5 [★★]
  ```
  ここまで与えた構文規則では，OCaml とは異なり， if，let, fun, match
  式などの「できるだけ右に延ばして読む」構文が二項演算子の右側に来た場合，
  括弧が必要になってしまう．この括弧が必要なくなるような構文規則を与えよ．
  例えば，
  1 + if true then 2 else 3;;
  などが正しいプログラムとして認められるようにせよ
  ```
  parserをいじるだけ、ということだけはすぐにわかると思うが、じゃあどうすんの、ってなりますよね。問題文の例のプログラムをぐっと睨むと優先...（これ以上言うと答えになってしまう）。
  * 実装難易度: 1
  * 発想難易度: B

- [ ] Ex.3.6.6、Ex.3.6.7 [(`･ω･´)]

  この研究室第1志望です！行きたい！っていう人がラブコールを送るための課題です。まあ希望の研究室に行きたければ8コマ4単位しかない実験に全力を注ぐより、まずは他の専門科目で良質な単位を取るべきだと私は思いますが。

### ML2 型推論
  
- [x] Ex.4.2.1 [必修]
  ```
  図4.1, 図4.2 に示すコードを参考にして，型推論アルゴリズムを完成させよ．
  ```
  二項演算子とif文とlet宣言の型推論が実装できますか？というぐらい。構文木が読めたらできると思います。

### ML3 型推論
  
- [x] Ex.4.3.1 [必修]
  ```
  図4.3 中のpp_ty，freevar_ty を完成させよ．freevar_ty は，
  与えられた型中の型変数の集合を返す関数で，型は
  val freevar_ty : ty -> tyvar MySet.t
  とする．型'a MySet.t はmySet.mli で定義されている'a を要素とする
  集合を表す型である
  ```

- [x] Ex.4.3.2 [必修]
  ```
  型代入に関する以下の型，関数をtyping.ml 中に実装せよ．
  type subst = (tyvar * ty) list
  val subst_type : subst -> ty -> ty
  例えば，
  let alpha = fresh_tyvar () in
  subst_type [(alpha, TyInt)] (TyFun (TyVar alpha, TyBool))
  の値はTyFun (TyInt, TyBool) になり，
  let alpha = fresh_tyvar () in
  let beta = fresh_tyvar () in
  subst_type [(beta, (TyFun (TyVar alpha, TyInt))); (alpha, TyBool)] (TyVar beta)
  の値はTyFun (TyBool, TyInt) になる．
  ```
- [x] Ex.4.3.3 [必修]
  ```
  上の単一化アルゴリズムを
  val unify : (ty * ty) list -> subst
  として実装せよ．
  ```

  Exercise 4.3.1から4.3.3まではテストケースがダミーの1ケースしか置かれていないので、<u>ちゃんとできているかどうかは、Exercise 4.3.5 が通るまでわからない</u>という感じになります(◞‸◟)‬ 先にEx.4.3.5をカンニングするといいと思います。

- [x] Ex.4.3.4 [必修]
  ```
  単一化アルゴリズムにおいて，α is not an element of FTV(τ) という条件は
  なぜ必要か考察せよ．
  ```
  逆にαがFTV(τ)の要素だったらどうなるかを考えればすぐわかると思う。

- [x] Ex.4.3.5 [必修]
  ```
  他の型付け規則に関しても同様に型推論の手続きを与えよ(レポートの一部としてまとめよ)．
  そして，図4.4 を参考にして，型推論アルゴリズムの実装を完成させよ．
  ```
  これができて、かつオプションで★5つ取っていればとりあえず単位は来ます！！ というところで最後に立ちはだかるのがコレ。実験のサイトに実行例が載っているので、とりあえず簡単な方から潰していくのがいいと思います。<font color="red">OCamlに準拠した型推論の結果表示じゃないとテストケース通りません。型変数が27個以上ある場合も考えてください。この辺は一応実験のサイトのFAQとかその辺に書いていますがついうっかり見落としちゃいます。</font>

  通らないケースがあれば、いろいろなところが間違っていると疑ってみてください。補助関数が間違っているかもしれないですし、単一化アルゴリズムが間違っているかもしれません。TAさんは優しいし、当然みんなに留年なんてしてほしくないはずなので、助けを求めればそれなりに対応してくれます。救難信号は出さないと意味がありません。

- [x] Ex.4.3.6 [★★]
  ```
  再帰的定義のためのlet rec 式の型付け規則は以下のように与えられる.
  （T-LETRECの規則がここにある）
  型推論アルゴリズムがlet rec 式を扱えるように拡張せよ．
  ```
  規則が読めたらきっとできるでしょう。単一化の時、制約が漏れていないかだけはよくチェックして。
  * 実装難易度: 2
  * 発想難易度: A

- [x] Ex.4.3.7 [★★]
  ```
  以下は，リスト操作に関する式の型付け規則である．
  リストには要素の型をτとしてτ list という型を与える．
  (T-NIL),(T-CONS),(T-MATCH)
  型推論アルゴリズムがこれらの式を扱えるように拡張せよ
  ```
  Ex.3.6.1ができていることが前提。T-NILとT-MATCHはここまでの内容が理解できていれば難しくはない。T-CONSをどうするかがちょっとだけ問題。
  * 実装難易度: 2
  * 発想難易度: A
  
### 多相的 let の型推論
  
- [ ] Ex.4.4.1 [★★]
  ```
  図4.5, 4.6 を参考にして，多相的let 式・宣言ともに扱える型推論アルゴリズムの実装を完成させよ．
  ```
  手をつけたが単純に実装量が多そうだし、難しそうなのでやめた。

- [ ] Ex.4.4.2 [★]
  ```
  以下の型付け規則を参考にして，再帰関数が多相的に扱えるように，
  型推論機能を拡張せよ．
  (T-LETREC)
  ```
  多分4.4.1ができたら楽勝なんだろうなーと。

- [ ] Ex.4.4.3 [★★★]
  ```
  OCaml では，「: ⟨ 型⟩」という形式で，式や宣言された変数の型を
  指定することができる．この機能を扱えるように処理系を拡張せよ．
  ```
  まずこの機能すら知らなかったんだが。

- [ ] Ex.4.4.4 [★★★]
  ```
  型推論時のエラー処理を，プログラマにエラー箇所がわかりやすくなるように改善せよ．
  ```
  「わかりやすく」って具体的になんなのかよくわからん。OCamlみたいに問題があった場所に下線を引いてエラーメッセージをエラー内容にしたがって全て分けるみたいな感じなのかな。